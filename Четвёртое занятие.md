<head>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>


# Четвёртое занятие (28/10/2024)
**Тема занятия:** Массивы (=векторы), небольшая подводка к указателям
## Массивы ##
**Что такое массив?**
Массив — это структура данных, которая представляет собой упорядоченный набор элементов одного типа. Каждый элемент массива имеет свой индекс, который используется для доступа к нему.
## Индексация массивов ##
Основной аспект индексации массивов, что она производится с **нуля**.

Индексы:  | 0 | 1 | 2 | 3 | 4 |
Элементы: | 5 | 7 | 9 | 1 | 6 |

При этом всём длина массива остаётся быть равной 5.

**Следовательно:**

Индексы:  | 0 | 1 | 2 | ... | i | ... | N-2 | N - 1 |
Элементы: | 5 | 7 | 9 | ... | a | ... |  b  |   c   |

Заметим, что i-ый элемент массива равен a, предпоследний под индексом N-2 является равен b, а последний элемент массива (под индексом N-1) равен c, следовательно для нас справедливо следующее утверждение, если N - количество элементов массива:

<p style="text-align: center">$$ 0 \leq i \leq N-1 $$</p>


## Виды массивов по виду выделения памяти: ##
1. Статические (инициализируется как {тип данных} {название переменной}[количество элементов], например: int array[10]. В квадратных скобках может также содержаться какая-то переменная **при условии**, что она является неизменяемой (const).
2. Динамические - можно выделить два основных типа динамических массивов, которые мы рассмотрим в рамках курса:
    1. Векторы - используются при импортировании библиотеки <vector>, которая позволяет использовать одноимённый тип данных для реализации динамических массивов.
    2. Ручное выделение памяти на массивы с использованием указателей. За частую это очень полезная вещь в случае задач, которые завязаны на том, чтобы достаточно жёстко контролировать память используемой программы.

Самый важный момент для понимания массивов: в большей части случаев, это заранее выделенное количество ячеек памяти под наши нужды, которые вместе и образуют один единый массив, который мы в дальнейшем и используем.

## Статические массивы: ##
Рассмотрим простейший пример:

```
#include <iostream>

using namespace std;
const int N = 100;

int main() {
    int array[10]; // хранит в себе 10 элементов
    long long arr[N]; // хранит 100 элементов (=N)
    cin >> array[0];
    return 0;
}
```
В фрагменте кода выше, мы инициализировали простейший массив, который будет длиной в 10 элементов, а также отдельно с помощью переменной проиллюстрирован пример создания массива с помощью константной переменной.

С помощью конструкции:
```
cin >> array[i];
```
Можно считывать элементы напрямую в массив под какой угодно индекс.
## Динамические массивы. Векторы. ##
В рамках этого занятия мы уделили больший акцент на векторы, нежели чем на ручное выделение памяти под массивы ввиду сложности данных операций, ведь прежде чем научиться делать вручную динамические массивы, нам стоит ознакомиться с арифметикой указателей, а прежде чем это делать, стоит разобраться в остальных аспектах языка.

Для работы с векторами, для начала подключим соответствующую библиотеку:
```
#include <vector>
```

Далее в теле функции main пропишем инициализацию вектора, но для начала отметим, что вектор инициализируется следующим форматом:
```
vector<тип_данных> название_переменной;
```
Следовательно, проинициализируем вектор для хранения целых чисел.
```
vector<int> array;
array.push_back(5);
```
Также мы используем функцию push_back, если хотим добавить элемент в конец массива.
Если же мы хотим напрямую изменить значение элемента вектора, то индексация также справедлива и для него:
```
array[0] = 15;
```
По умолчанию, вектор является пустым. Следовательно, либо необходимо его проинициализировать с уже заданным числом элементов, либо же постепенно добавлять элементы в него.

Виды инициализаций вектора:
```
vector<int> v1(5);       // вектор состоит из 5 чисел, каждое число в векторе равно 0
vector<int> v2{5};       // вектор состоит из одного числа, которое равно 5
vector<int> v3(5, 2);    // вектор состоит из 5 чисел, каждое число равно 2
vector<int> v4{5, 2};    // вектор состоит из двух чисел 5 и 2
vector<int> v5(v1);      // вектор v5 - копия вектора v1
vector<int> v6 = v1;     // вектор v6 - копия вектора v1
vector<int> v7 = {1, 2, 3, 5}; // вектор v7 состоит из чисел 1, 2, 3, 5
```
## Оценка эффективности программы ##
Очень важный аспект перед изучением любых алгоритмов - понимание того, зачем они нам нужны.
Алгоритмы используются для оптимизации поставленных задач, следовательно мы должны уметь оценивать их работы. Для оценки временной сложности и оценки по памяти, принято использовать нотацию О-большое.
Что это означает? Что количество производимых операций кодом - например, итераций, или же количество выделяемой памяти, при чём эти параметры обязательно должны зависеть от какой-нибудь величины (например, вводят число N и мы должны вывести все числа от 1 до N - сложность программы здесь зависит от вводимого параметра N).
Таким образом введём следующие сложности, с которыми мы будем работать в большинстве случаев:
1. $$O(1)$$ - наилучший случай, отсутствует какая-либо зависимость, то есть всё выполняется мгновенно. Это та асимптотика, к которой мы стремимся.
2. $$O(N)$$ - линейная сложность (аналогично линейной функции).
3. $$O(\sqrt N)$$ - коренная сложность.
4. $$O(N^2)$$ - квадратичная сложность.
Это самые базовые случаи, которые мы используем для начала.
![](https://habrastorage.org/getpro/habr/upload_files/973/455/cf3/973455cf3bb354f49113562838372900.jpg)

## Решето Эратосфена ##
Решето Эратосфена — это древний алгоритм для нахождения всех простых чисел до заданного предела. Он был разработан греческим математиком Эратосфеном в III веке до нашей эры. Этот метод эффективен и прост в реализации, что делает его популярным для работы с простыми числами. 
Когда мы решали задачу о поиске простых чисел, которые меньше вводимого числа, мы писали простейший перебор с помощью цикла всех чисел, а после проверяли - простое ли каждое из них. В данном случае асимптотика была равна $$O(N\sqrt N)$$, в случае же с алгоритмом Решета Эратосфена - асимптотика многократно улучшается и становится равна
$$O(N\log N)$$.

В чём заключается суть Решета Эратосфена? 
Давайте выпишем все числа из нужного нам диапазона, допустим это будут числа от 0 до 19: 
```
0 1 2 3 4 5 6 7 8 9
10 11 12 13 14 15 16 17 18 19 20
```
Давайте вычеркнем 0 и 1, так как они по определению не являются простыми числами:
```
2 3 4 5 6 7 8 9 10 11
12 13 14 15 16 17 18 19 20
```
Давайте считать, что на данный момент все эти числа являются простыми. Первое такое число - **2**. А теперь давайте убирать все числа, которые кратны этому, получаем:
```
2 3 5 7 9 11
13 15 17 19
```
Перейдём к следующему числу - 3. Давайте по аналогии убирать все числа, кратные ему:
```
2 3 5 7 11
13 17 19
```
И мы бы продолжили так делать, но в случае с выбранными диапазоном, даже если мы продолжим, вычёркивать уже нечего.

**Следовательно:** всё, что осталось, является нашим ответом - набором простых чисел на диапазоне.
## Задание на дом: ##
1. Реализовать Решето Эратосфена, используя лишь один массив.
